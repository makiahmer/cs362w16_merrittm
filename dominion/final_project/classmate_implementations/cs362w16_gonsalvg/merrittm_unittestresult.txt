~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unit Testing - Assign 2 - Run: Sun Mar 13 12:06:12 PDT 2016
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=================================================
merrittm_unittest1
File 'dominion.c'
Lines executed:21.58% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
      300:   13:int compare(const void* a, const void* b) {
      300:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
      300:   16:	if (*(int*)a < *(int*)b)
       80:   17:		return -1;
      220:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       10:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       10:   49:	SelectStream(1);
       10:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       10:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       10:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      110:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     1100:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     1000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       10:   78:	if (numPlayers == 2)
        -:   79:	{
       10:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       10:   92:	if (numPlayers == 2)
        -:   93:	{
       10:   94:		state->supplyCount[estate] = 8;
       10:   95:		state->supplyCount[duchy] = 8;
       10:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       10:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  107:	state->supplyCount[silver] = 40;
       10:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
      210:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     1650:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     1550:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      120:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
       20:  120:					if (numPlayers == 2) {
       20:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
       80:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      100:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     1450:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
       30:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
       20:  145:		state->deckCount[i] = 0;
       80:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
       60:  148:			state->deck[i][j] = estate;
       60:  149:			state->deckCount[i]++;
        -:  150:		}
      160:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      140:  153:			state->deck[i][j] = copper;
      140:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
       30:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
       20:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
       30:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
       20:  171:		state->handCount[i] = 0;
       20:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
      280:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
      270:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       10:  187:	state->outpostPlayed = 0;
       10:  188:	state->phase = 0;
       10:  189:	state->numActions = 1;
       10:  190:	state->numBuys = 1;
       10:  191:	state->playedCardCount = 0;
       10:  192:	state->whoseTurn = 0;
       10:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
       60:  197:	for (it = 0; it < 5; it++) {
       50:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       10:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       10:  203:	return 0;
        -:  204:}
        -:  205:
       20:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
       20:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
       20:  214:	if (state->deckCount[player] < 1)
    #####:  215:		return -1;
       20:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
      240:  219:	while (state->deckCount[player] > 0) {
      200:  220:		card = floor(Random() * state->deckCount[player]);
      200:  221:		newDeck[newDeckPos] = state->deck[player][card];
      200:  222:		newDeckPos++;
      760:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
      560:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
      200:  226:		state->deckCount[player]--;
        -:  227:	}
      220:  228:	for (i = 0; i < newDeckPos; i++) {
      200:  229:		state->deck[player][i] = newDeck[i];
      200:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
       20:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
    #####:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
    #####:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
    #####:  285:	who = state->whoseTurn;
        -:  286:
    #####:  287:	if (state->numBuys < 1) {
    #####:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (supplyCount(supplyPos, state) < 1) {
    #####:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
    #####:  295:		return -1;
        -:  296:	}
    #####:  297:	else if (state->coins < getCost(supplyPos)) {
    #####:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:		return -1;
        -:  301:	}
        -:  302:	else {
    #####:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
    #####:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
    #####:  307:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  308:		state->numBuys--;
    #####:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
    #####:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
    #####:  328:int supplyCount(int card, struct gameState *state) {
    #####:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
    #####:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
    #####:  334:	int count = 0;
        -:  335:
    #####:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    #####:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
    #####:  351:	return count;
        -:  352:}
        -:  353:
      200:  354:int whoseTurn(struct gameState *state) {
      200:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
       50:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
       50:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
    #####:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
    #####:  547:		state->deckCount[player] = state->discardCount[player];
    #####:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
    #####:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
    #####:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
    #####:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
    #####:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
    #####:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
    #####:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
    #####:  568:		if (deckCounter == 0)
    #####:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
       50:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
       50:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
       50:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  585:		state->deckCount[player]--;
       50:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
       50:  589:	return 0;
        -:  590:}
        -:  591:
    #####:  592:int getCost(int cardNumber)
        -:  593:{
    #####:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
    #####:  597:		return 0;
        -:  598:	case estate:
    #####:  599:		return 2;
        -:  600:	case duchy:
    #####:  601:		return 5;
        -:  602:	case province:
    #####:  603:		return 8;
        -:  604:	case copper:
    #####:  605:		return 0;
        -:  606:	case silver:
    #####:  607:		return 3;
        -:  608:	case gold:
    #####:  609:		return 6;
        -:  610:	case adventurer:
    #####:  611:		return 6;
        -:  612:	case council_room:
    #####:  613:		return 5;
        -:  614:	case feast:
    #####:  615:		return 4;
        -:  616:	case gardens:
    #####:  617:		return 4;
        -:  618:	case mine:
    #####:  619:		return 5;
        -:  620:	case remodel:
    #####:  621:		return 4;
        -:  622:	case smithy:
    #####:  623:		return 4;
        -:  624:	case village:
    #####:  625:		return 3;
        -:  626:	case baron:
    #####:  627:		return 4;
        -:  628:	case great_hall:
    #####:  629:		return 3;
        -:  630:	case minion:
    #####:  631:		return 5;
        -:  632:	case steward:
    #####:  633:		return 3;
        -:  634:	case tribute:
    #####:  635:		return 5;
        -:  636:	case ambassador:
    #####:  637:		return 3;
        -:  638:	case cutpurse:
    #####:  639:		return 4;
        -:  640:	case embargo:
    #####:  641:		return 2;
        -:  642:	case outpost:
    #####:  643:		return 5;
        -:  644:	case salvager:
    #####:  645:		return 4;
        -:  646:	case sea_hag:
    #####:  647:		return 4;
        -:  648:	case treasure_map:
    #####:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       50:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       50:  658:	int i = 0;
       50:  659:	int j = 0;
       50:  660:	int k = 0;
       50:  661:	int x = 0;
       50:  662:	int index = 0;
       50:  663:	int currentPlayer = whoseTurn(state);
       50:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       50:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       50:  668:	int drawntreasure = 0;
       50:  669:	int cardDrawn = 0;
       50:  670:	int z = 0;// this is the counter for the temp hand
       50:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       50:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
    #####:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
    #####:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
    #####:  831:		state->numBuys++;//Increase buys by 1!
    #####:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
    #####:  869:			if (supplyCount(estate, state) > 0) {
    #####:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:				state->supplyCount[estate]--;//Decrement Estates
    #####:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
    #####:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
    #####:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
    #####:  891:			drawCard(currentPlayer, state);
    #####:  892:			drawCard(currentPlayer, state);
        -:  893:		}
    #####:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
    #####:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
    #####:  902:			discardCard(choice2, currentPlayer, state, 1);
    #####:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
    #####:  907:		discardCard(handPos, currentPlayer, state, 0);
    #####:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
    #####: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
    #####: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
    #####: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
    #####: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
    #####: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
    #####: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
    #####: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
    #####: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
    #####: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
    #####: 1182:	return 0;
        -: 1183:}
        -: 1184:
    #####: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
    #####: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
    #####: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
    #####: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
    #####: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
    #####: 1219:	return 0;
        -: 1220:}
        -: 1221:
       10: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       10: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
       60: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
       50: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
       40: 1234:			state->coins += 1;
        -: 1235:		}
       10: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
    #####: 1238:			state->coins += 2;
        -: 1239:		}
       10: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
    #####: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       10: 1247:	state->coins += bonus;
        -: 1248:
       10: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
    #####: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
    #####: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
    #####: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
    #####: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
    #####: 1288:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
    #####: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
    #####: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
    #####: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
    #####: 1302:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_unittest2
File 'dominion.c'
Lines executed:21.92% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:2
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
      600:   13:int compare(const void* a, const void* b) {
      600:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
      600:   16:	if (*(int*)a < *(int*)b)
      160:   17:		return -1;
      440:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       20:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       20:   49:	SelectStream(1);
       20:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       20:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       20:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      220:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     2200:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     2000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       20:   78:	if (numPlayers == 2)
        -:   79:	{
       20:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       20:   92:	if (numPlayers == 2)
        -:   93:	{
       20:   94:		state->supplyCount[estate] = 8;
       20:   95:		state->supplyCount[duchy] = 8;
       20:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       20:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       20:  107:	state->supplyCount[silver] = 40;
       20:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
      420:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     3300:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     3100:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      240:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
       40:  120:					if (numPlayers == 2) {
       40:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      160:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      200:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     2900:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
       60:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
       40:  145:		state->deckCount[i] = 0;
      160:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      120:  148:			state->deck[i][j] = estate;
      120:  149:			state->deckCount[i]++;
        -:  150:		}
      320:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      280:  153:			state->deck[i][j] = copper;
      280:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
       60:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
       40:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
       60:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
       40:  171:		state->handCount[i] = 0;
       40:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
      560:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
      540:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       20:  187:	state->outpostPlayed = 0;
       20:  188:	state->phase = 0;
       20:  189:	state->numActions = 1;
       20:  190:	state->numBuys = 1;
       20:  191:	state->playedCardCount = 0;
       20:  192:	state->whoseTurn = 0;
       20:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      120:  197:	for (it = 0; it < 5; it++) {
      100:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       20:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       20:  203:	return 0;
        -:  204:}
        -:  205:
       40:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
       40:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
       40:  214:	if (state->deckCount[player] < 1)
    #####:  215:		return -1;
       40:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
      480:  219:	while (state->deckCount[player] > 0) {
      400:  220:		card = floor(Random() * state->deckCount[player]);
      400:  221:		newDeck[newDeckPos] = state->deck[player][card];
      400:  222:		newDeckPos++;
     1520:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     1120:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
      400:  226:		state->deckCount[player]--;
        -:  227:	}
      440:  228:	for (i = 0; i < newDeckPos; i++) {
      400:  229:		state->deck[player][i] = newDeck[i];
      400:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
       40:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
    #####:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
    #####:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
    #####:  285:	who = state->whoseTurn;
        -:  286:
    #####:  287:	if (state->numBuys < 1) {
    #####:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (supplyCount(supplyPos, state) < 1) {
    #####:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
    #####:  295:		return -1;
        -:  296:	}
    #####:  297:	else if (state->coins < getCost(supplyPos)) {
    #####:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:		return -1;
        -:  301:	}
        -:  302:	else {
    #####:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
    #####:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
    #####:  307:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  308:		state->numBuys--;
    #####:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
    #####:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
    #####:  328:int supplyCount(int card, struct gameState *state) {
    #####:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
    #####:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
    #####:  334:	int count = 0;
        -:  335:
    #####:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    #####:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
    #####:  351:	return count;
        -:  352:}
        -:  353:
      200:  354:int whoseTurn(struct gameState *state) {
      200:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      100:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      100:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
    #####:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
    #####:  547:		state->deckCount[player] = state->discardCount[player];
    #####:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
    #####:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
    #####:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
    #####:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
    #####:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
    #####:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
    #####:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
    #####:  568:		if (deckCounter == 0)
    #####:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      100:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      100:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      100:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      100:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      100:  585:		state->deckCount[player]--;
      100:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      100:  589:	return 0;
        -:  590:}
        -:  591:
    #####:  592:int getCost(int cardNumber)
        -:  593:{
    #####:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
    #####:  597:		return 0;
        -:  598:	case estate:
    #####:  599:		return 2;
        -:  600:	case duchy:
    #####:  601:		return 5;
        -:  602:	case province:
    #####:  603:		return 8;
        -:  604:	case copper:
    #####:  605:		return 0;
        -:  606:	case silver:
    #####:  607:		return 3;
        -:  608:	case gold:
    #####:  609:		return 6;
        -:  610:	case adventurer:
    #####:  611:		return 6;
        -:  612:	case council_room:
    #####:  613:		return 5;
        -:  614:	case feast:
    #####:  615:		return 4;
        -:  616:	case gardens:
    #####:  617:		return 4;
        -:  618:	case mine:
    #####:  619:		return 5;
        -:  620:	case remodel:
    #####:  621:		return 4;
        -:  622:	case smithy:
    #####:  623:		return 4;
        -:  624:	case village:
    #####:  625:		return 3;
        -:  626:	case baron:
    #####:  627:		return 4;
        -:  628:	case great_hall:
    #####:  629:		return 3;
        -:  630:	case minion:
    #####:  631:		return 5;
        -:  632:	case steward:
    #####:  633:		return 3;
        -:  634:	case tribute:
    #####:  635:		return 5;
        -:  636:	case ambassador:
    #####:  637:		return 3;
        -:  638:	case cutpurse:
    #####:  639:		return 4;
        -:  640:	case embargo:
    #####:  641:		return 2;
        -:  642:	case outpost:
    #####:  643:		return 5;
        -:  644:	case salvager:
    #####:  645:		return 4;
        -:  646:	case sea_hag:
    #####:  647:		return 4;
        -:  648:	case treasure_map:
    #####:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       50:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       50:  658:	int i = 0;
       50:  659:	int j = 0;
       50:  660:	int k = 0;
       50:  661:	int x = 0;
       50:  662:	int index = 0;
       50:  663:	int currentPlayer = whoseTurn(state);
       50:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       50:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       50:  668:	int drawntreasure = 0;
       50:  669:	int cardDrawn = 0;
       50:  670:	int z = 0;// this is the counter for the temp hand
       50:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       50:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
    #####:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
    #####:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
    #####:  831:		state->numBuys++;//Increase buys by 1!
    #####:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
    #####:  869:			if (supplyCount(estate, state) > 0) {
    #####:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:				state->supplyCount[estate]--;//Decrement Estates
    #####:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
    #####:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
    #####:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
    #####:  891:			drawCard(currentPlayer, state);
    #####:  892:			drawCard(currentPlayer, state);
        -:  893:		}
    #####:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
    #####:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
    #####:  902:			discardCard(choice2, currentPlayer, state, 1);
    #####:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
    #####:  907:		discardCard(handPos, currentPlayer, state, 0);
    #####:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
    #####: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
    #####: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
    #####: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
    #####: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
    #####: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
    #####: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
    #####: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
    #####: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
    #####: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
    #####: 1182:	return 0;
        -: 1183:}
        -: 1184:
    #####: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
    #####: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
    #####: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
    #####: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
    #####: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
    #####: 1219:	return 0;
        -: 1220:}
        -: 1221:
       50: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       50: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      300: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      250: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      130: 1234:			state->coins += 1;
        -: 1235:		}
      120: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
       70: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       50: 1247:	state->coins += bonus;
        -: 1248:
       50: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
    #####: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
    #####: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
    #####: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
    #####: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
    #####: 1288:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
    #####: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
    #####: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
    #####: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
    #####: 1302:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_unittest3
File 'dominion.c'
Lines executed:23.46% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
      900:   13:int compare(const void* a, const void* b) {
      900:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
      900:   16:	if (*(int*)a < *(int*)b)
      240:   17:		return -1;
      660:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       30:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       30:   49:	SelectStream(1);
       30:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       30:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       30:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      330:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     3300:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     3000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       30:   78:	if (numPlayers == 2)
        -:   79:	{
       30:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       30:   92:	if (numPlayers == 2)
        -:   93:	{
       30:   94:		state->supplyCount[estate] = 8;
       30:   95:		state->supplyCount[duchy] = 8;
       30:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       30:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       30:  107:	state->supplyCount[silver] = 40;
       30:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
      630:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     4950:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     4650:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      360:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
       60:  120:					if (numPlayers == 2) {
       60:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      240:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      300:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     4350:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
       90:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
       60:  145:		state->deckCount[i] = 0;
      240:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      180:  148:			state->deck[i][j] = estate;
      180:  149:			state->deckCount[i]++;
        -:  150:		}
      480:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      420:  153:			state->deck[i][j] = copper;
      420:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
       90:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
       60:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
       90:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
       60:  171:		state->handCount[i] = 0;
       60:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
      840:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
      810:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       30:  187:	state->outpostPlayed = 0;
       30:  188:	state->phase = 0;
       30:  189:	state->numActions = 1;
       30:  190:	state->numBuys = 1;
       30:  191:	state->playedCardCount = 0;
       30:  192:	state->whoseTurn = 0;
       30:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      180:  197:	for (it = 0; it < 5; it++) {
      150:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       30:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       30:  203:	return 0;
        -:  204:}
        -:  205:
       60:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
       60:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
       60:  214:	if (state->deckCount[player] < 1)
    #####:  215:		return -1;
       60:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
      720:  219:	while (state->deckCount[player] > 0) {
      600:  220:		card = floor(Random() * state->deckCount[player]);
      600:  221:		newDeck[newDeckPos] = state->deck[player][card];
      600:  222:		newDeckPos++;
     2280:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     1680:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
      600:  226:		state->deckCount[player]--;
        -:  227:	}
      660:  228:	for (i = 0; i < newDeckPos; i++) {
      600:  229:		state->deck[player][i] = newDeck[i];
      600:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
       60:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
    #####:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
    #####:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
    #####:  285:	who = state->whoseTurn;
        -:  286:
    #####:  287:	if (state->numBuys < 1) {
    #####:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (supplyCount(supplyPos, state) < 1) {
    #####:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
    #####:  295:		return -1;
        -:  296:	}
    #####:  297:	else if (state->coins < getCost(supplyPos)) {
    #####:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  300:		return -1;
        -:  301:	}
        -:  302:	else {
    #####:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
    #####:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
    #####:  307:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  308:		state->numBuys--;
    #####:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
    #####:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
    #####:  328:int supplyCount(int card, struct gameState *state) {
    #####:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      560:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      560:  334:	int count = 0;
        -:  335:
     3360:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     2800:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3360:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     2800:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23240:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22680:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      560:  351:	return count;
        -:  352:}
        -:  353:
      200:  354:int whoseTurn(struct gameState *state) {
      200:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      150:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      150:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
    #####:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
    #####:  547:		state->deckCount[player] = state->discardCount[player];
    #####:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
    #####:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
    #####:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
    #####:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
    #####:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
    #####:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
    #####:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
    #####:  568:		if (deckCounter == 0)
    #####:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      150:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      150:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      150:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      150:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      150:  585:		state->deckCount[player]--;
      150:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      150:  589:	return 0;
        -:  590:}
        -:  591:
    #####:  592:int getCost(int cardNumber)
        -:  593:{
    #####:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
    #####:  597:		return 0;
        -:  598:	case estate:
    #####:  599:		return 2;
        -:  600:	case duchy:
    #####:  601:		return 5;
        -:  602:	case province:
    #####:  603:		return 8;
        -:  604:	case copper:
    #####:  605:		return 0;
        -:  606:	case silver:
    #####:  607:		return 3;
        -:  608:	case gold:
    #####:  609:		return 6;
        -:  610:	case adventurer:
    #####:  611:		return 6;
        -:  612:	case council_room:
    #####:  613:		return 5;
        -:  614:	case feast:
    #####:  615:		return 4;
        -:  616:	case gardens:
    #####:  617:		return 4;
        -:  618:	case mine:
    #####:  619:		return 5;
        -:  620:	case remodel:
    #####:  621:		return 4;
        -:  622:	case smithy:
    #####:  623:		return 4;
        -:  624:	case village:
    #####:  625:		return 3;
        -:  626:	case baron:
    #####:  627:		return 4;
        -:  628:	case great_hall:
    #####:  629:		return 3;
        -:  630:	case minion:
    #####:  631:		return 5;
        -:  632:	case steward:
    #####:  633:		return 3;
        -:  634:	case tribute:
    #####:  635:		return 5;
        -:  636:	case ambassador:
    #####:  637:		return 3;
        -:  638:	case cutpurse:
    #####:  639:		return 4;
        -:  640:	case embargo:
    #####:  641:		return 2;
        -:  642:	case outpost:
    #####:  643:		return 5;
        -:  644:	case salvager:
    #####:  645:		return 4;
        -:  646:	case sea_hag:
    #####:  647:		return 4;
        -:  648:	case treasure_map:
    #####:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       50:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       50:  658:	int i = 0;
       50:  659:	int j = 0;
       50:  660:	int k = 0;
       50:  661:	int x = 0;
       50:  662:	int index = 0;
       50:  663:	int currentPlayer = whoseTurn(state);
       50:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       50:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       50:  668:	int drawntreasure = 0;
       50:  669:	int cardDrawn = 0;
       50:  670:	int z = 0;// this is the counter for the temp hand
       50:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       50:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
    #####:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
    #####:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
    #####:  831:		state->numBuys++;//Increase buys by 1!
    #####:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
    #####:  869:			if (supplyCount(estate, state) > 0) {
    #####:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:				state->supplyCount[estate]--;//Decrement Estates
    #####:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
    #####:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
    #####:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
    #####:  891:			drawCard(currentPlayer, state);
    #####:  892:			drawCard(currentPlayer, state);
        -:  893:		}
    #####:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
    #####:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
    #####:  902:			discardCard(choice2, currentPlayer, state, 1);
    #####:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
    #####:  907:		discardCard(handPos, currentPlayer, state, 0);
    #####:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
    #####: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
    #####: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
    #####: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
    #####: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
    #####: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
    #####: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
    #####: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
    #####: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
    #####: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
    #####: 1182:	return 0;
        -: 1183:}
        -: 1184:
    #####: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
    #####: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
    #####: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
    #####: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
    #####: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
    #####: 1219:	return 0;
        -: 1220:}
        -: 1221:
       60: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       60: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      360: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      300: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      170: 1234:			state->coins += 1;
        -: 1235:		}
      130: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
       80: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       60: 1247:	state->coins += bonus;
        -: 1248:
       60: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
    #####: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
    #####: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
    #####: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
    #####: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
    #####: 1288:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
    #####: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
    #####: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
    #####: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
    #####: 1302:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_unittest4
File 'dominion.c'
Lines executed:33.22% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:4
        -:    0:Programs:4
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
     1200:   13:int compare(const void* a, const void* b) {
     1200:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
     1200:   16:	if (*(int*)a < *(int*)b)
      320:   17:		return -1;
      880:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       40:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       40:   49:	SelectStream(1);
       40:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       40:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       40:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      440:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     4400:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     4000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       40:   78:	if (numPlayers == 2)
        -:   79:	{
       40:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       40:   92:	if (numPlayers == 2)
        -:   93:	{
       40:   94:		state->supplyCount[estate] = 8;
       40:   95:		state->supplyCount[duchy] = 8;
       40:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       40:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       40:  107:	state->supplyCount[silver] = 40;
       40:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
      840:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     6600:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     6200:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      480:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
       80:  120:					if (numPlayers == 2) {
       80:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      320:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      400:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     5800:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
      120:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
       80:  145:		state->deckCount[i] = 0;
      320:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      240:  148:			state->deck[i][j] = estate;
      240:  149:			state->deckCount[i]++;
        -:  150:		}
      640:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      560:  153:			state->deck[i][j] = copper;
      560:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
      120:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
       80:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
      120:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
       80:  171:		state->handCount[i] = 0;
       80:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
     1120:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
     1080:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       40:  187:	state->outpostPlayed = 0;
       40:  188:	state->phase = 0;
       40:  189:	state->numActions = 1;
       40:  190:	state->numBuys = 1;
       40:  191:	state->playedCardCount = 0;
       40:  192:	state->whoseTurn = 0;
       40:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      240:  197:	for (it = 0; it < 5; it++) {
      200:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       40:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       40:  203:	return 0;
        -:  204:}
        -:  205:
       80:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
       80:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
       80:  214:	if (state->deckCount[player] < 1)
    #####:  215:		return -1;
       80:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
      960:  219:	while (state->deckCount[player] > 0) {
      800:  220:		card = floor(Random() * state->deckCount[player]);
      800:  221:		newDeck[newDeckPos] = state->deck[player][card];
      800:  222:		newDeckPos++;
     3040:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2240:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
      800:  226:		state->deckCount[player]--;
        -:  227:	}
      880:  228:	for (i = 0; i < newDeckPos; i++) {
      800:  229:		state->deck[player][i] = newDeck[i];
      800:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
       80:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
     5670:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
     5670:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
     5670:  285:	who = state->whoseTurn;
        -:  286:
     5670:  287:	if (state->numBuys < 1) {
     1620:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
     1620:  290:		return -1;
        -:  291:	}
     4050:  292:	else if (supplyCount(supplyPos, state) < 1) {
     2510:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
     2510:  295:		return -1;
        -:  296:	}
     1540:  297:	else if (state->coins < getCost(supplyPos)) {
     1510:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
     1510:  300:		return -1;
        -:  301:	}
        -:  302:	else {
       30:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
       30:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
       30:  307:		state->coins = (state->coins) - (getCost(supplyPos));
       30:  308:		state->numBuys--;
       30:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
       30:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
     4120:  328:int supplyCount(int card, struct gameState *state) {
     4120:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      620:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      620:  334:	int count = 0;
        -:  335:
     3720:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     3100:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3720:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     3100:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23390:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22770:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      620:  351:	return count;
        -:  352:}
        -:  353:
      200:  354:int whoseTurn(struct gameState *state) {
      200:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      200:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      200:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
    #####:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
    #####:  547:		state->deckCount[player] = state->discardCount[player];
    #####:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
    #####:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
    #####:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
    #####:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
    #####:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
    #####:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
    #####:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
    #####:  568:		if (deckCounter == 0)
    #####:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      200:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      200:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      200:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      200:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      200:  585:		state->deckCount[player]--;
      200:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      200:  589:	return 0;
        -:  590:}
        -:  591:
     4540:  592:int getCost(int cardNumber)
        -:  593:{
     4540:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
      150:  597:		return 0;
        -:  598:	case estate:
      190:  599:		return 2;
        -:  600:	case duchy:
      220:  601:		return 5;
        -:  602:	case province:
      280:  603:		return 8;
        -:  604:	case copper:
      150:  605:		return 0;
        -:  606:	case silver:
      180:  607:		return 3;
        -:  608:	case gold:
      240:  609:		return 6;
        -:  610:	case adventurer:
      240:  611:		return 6;
        -:  612:	case council_room:
      220:  613:		return 5;
        -:  614:	case feast:
      200:  615:		return 4;
        -:  616:	case gardens:
      200:  617:		return 4;
        -:  618:	case mine:
      220:  619:		return 5;
        -:  620:	case remodel:
      200:  621:		return 4;
        -:  622:	case smithy:
      200:  623:		return 4;
        -:  624:	case village:
      180:  625:		return 3;
        -:  626:	case baron:
      200:  627:		return 4;
        -:  628:	case great_hall:
      180:  629:		return 3;
        -:  630:	case minion:
      120:  631:		return 5;
        -:  632:	case steward:
      100:  633:		return 3;
        -:  634:	case tribute:
      120:  635:		return 5;
        -:  636:	case ambassador:
      100:  637:		return 3;
        -:  638:	case cutpurse:
      110:  639:		return 4;
        -:  640:	case embargo:
       90:  641:		return 2;
        -:  642:	case outpost:
      120:  643:		return 5;
        -:  644:	case salvager:
      110:  645:		return 4;
        -:  646:	case sea_hag:
      110:  647:		return 4;
        -:  648:	case treasure_map:
      110:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       50:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       50:  658:	int i = 0;
       50:  659:	int j = 0;
       50:  660:	int k = 0;
       50:  661:	int x = 0;
       50:  662:	int index = 0;
       50:  663:	int currentPlayer = whoseTurn(state);
       50:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       50:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       50:  668:	int drawntreasure = 0;
       50:  669:	int cardDrawn = 0;
       50:  670:	int z = 0;// this is the counter for the temp hand
       50:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       50:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
    #####:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
    #####:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
    #####:  831:		state->numBuys++;//Increase buys by 1!
    #####:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
    #####:  869:			if (supplyCount(estate, state) > 0) {
    #####:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:				state->supplyCount[estate]--;//Decrement Estates
    #####:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
    #####:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
    #####:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
    #####:  891:			drawCard(currentPlayer, state);
    #####:  892:			drawCard(currentPlayer, state);
        -:  893:		}
    #####:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
    #####:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
    #####:  902:			discardCard(choice2, currentPlayer, state, 1);
    #####:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
    #####:  907:		discardCard(handPos, currentPlayer, state, 0);
    #####:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
    #####: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
    #####: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
    #####: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
    #####: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
    #####: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
    #####: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
    #####: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
    #####: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
    #####: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
    #####: 1182:	return 0;
        -: 1183:}
        -: 1184:
       30: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
       30: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
       30: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
       30: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
       30: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
       30: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
       30: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
       30: 1219:	return 0;
        -: 1220:}
        -: 1221:
       70: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       70: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      420: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      350: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      210: 1234:			state->coins += 1;
        -: 1235:		}
      140: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
       90: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       70: 1247:	state->coins += bonus;
        -: 1248:
       70: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
    #####: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
    #####: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
    #####: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
    #####: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
    #####: 1288:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
    #####: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
    #####: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
    #####: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
    #####: 1302:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_cardtest1
File 'dominion.c'
Lines executed:38.70% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:5
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
     1500:   13:int compare(const void* a, const void* b) {
     1500:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
     1500:   16:	if (*(int*)a < *(int*)b)
      400:   17:		return -1;
     1100:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       50:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       50:   49:	SelectStream(1);
       50:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       50:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       50:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      550:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     5500:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     5000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       50:   78:	if (numPlayers == 2)
        -:   79:	{
       50:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       50:   92:	if (numPlayers == 2)
        -:   93:	{
       50:   94:		state->supplyCount[estate] = 8;
       50:   95:		state->supplyCount[duchy] = 8;
       50:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       50:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       50:  107:	state->supplyCount[silver] = 40;
       50:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
     1050:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     8250:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     7750:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      600:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
      100:  120:					if (numPlayers == 2) {
      100:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      400:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      500:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     7250:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
      150:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
      100:  145:		state->deckCount[i] = 0;
      400:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      300:  148:			state->deck[i][j] = estate;
      300:  149:			state->deckCount[i]++;
        -:  150:		}
      800:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      700:  153:			state->deck[i][j] = copper;
      700:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
      150:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
      100:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
      150:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
      100:  171:		state->handCount[i] = 0;
      100:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
     1400:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
     1350:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       50:  187:	state->outpostPlayed = 0;
       50:  188:	state->phase = 0;
       50:  189:	state->numActions = 1;
       50:  190:	state->numBuys = 1;
       50:  191:	state->playedCardCount = 0;
       50:  192:	state->whoseTurn = 0;
       50:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      300:  197:	for (it = 0; it < 5; it++) {
      250:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       50:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       50:  203:	return 0;
        -:  204:}
        -:  205:
      121:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
      121:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
      121:  214:	if (state->deckCount[player] < 1)
       21:  215:		return -1;
      100:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
     1200:  219:	while (state->deckCount[player] > 0) {
     1000:  220:		card = floor(Random() * state->deckCount[player]);
     1000:  221:		newDeck[newDeckPos] = state->deck[player][card];
     1000:  222:		newDeckPos++;
     3800:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2800:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
     1000:  226:		state->deckCount[player]--;
        -:  227:	}
     1100:  228:	for (i = 0; i < newDeckPos; i++) {
     1000:  229:		state->deck[player][i] = newDeck[i];
     1000:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
      100:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
     5670:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
     5670:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
     5670:  285:	who = state->whoseTurn;
        -:  286:
     5670:  287:	if (state->numBuys < 1) {
     1620:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
     1620:  290:		return -1;
        -:  291:	}
     4050:  292:	else if (supplyCount(supplyPos, state) < 1) {
     2510:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
     2510:  295:		return -1;
        -:  296:	}
     1540:  297:	else if (state->coins < getCost(supplyPos)) {
     1510:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
     1510:  300:		return -1;
        -:  301:	}
        -:  302:	else {
       30:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
       30:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
       30:  307:		state->coins = (state->coins) - (getCost(supplyPos));
       30:  308:		state->numBuys--;
       30:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
       30:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
     4120:  328:int supplyCount(int card, struct gameState *state) {
     4120:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      620:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      620:  334:	int count = 0;
        -:  335:
     3720:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     3100:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3720:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     3100:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23390:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22770:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      620:  351:	return count;
        -:  352:}
        -:  353:
      230:  354:int whoseTurn(struct gameState *state) {
      230:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      315:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      315:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
       21:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
       21:  547:		state->deckCount[player] = state->discardCount[player];
       21:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
       21:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
       21:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
       21:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
       21:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
       21:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
       21:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
       21:  568:		if (deckCounter == 0)
       21:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      294:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      294:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      294:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      294:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      294:  585:		state->deckCount[player]--;
      294:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      294:  589:	return 0;
        -:  590:}
        -:  591:
     4540:  592:int getCost(int cardNumber)
        -:  593:{
     4540:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
      150:  597:		return 0;
        -:  598:	case estate:
      190:  599:		return 2;
        -:  600:	case duchy:
      220:  601:		return 5;
        -:  602:	case province:
      280:  603:		return 8;
        -:  604:	case copper:
      150:  605:		return 0;
        -:  606:	case silver:
      180:  607:		return 3;
        -:  608:	case gold:
      240:  609:		return 6;
        -:  610:	case adventurer:
      240:  611:		return 6;
        -:  612:	case council_room:
      220:  613:		return 5;
        -:  614:	case feast:
      200:  615:		return 4;
        -:  616:	case gardens:
      200:  617:		return 4;
        -:  618:	case mine:
      220:  619:		return 5;
        -:  620:	case remodel:
      200:  621:		return 4;
        -:  622:	case smithy:
      200:  623:		return 4;
        -:  624:	case village:
      180:  625:		return 3;
        -:  626:	case baron:
      200:  627:		return 4;
        -:  628:	case great_hall:
      180:  629:		return 3;
        -:  630:	case minion:
      120:  631:		return 5;
        -:  632:	case steward:
      100:  633:		return 3;
        -:  634:	case tribute:
      120:  635:		return 5;
        -:  636:	case ambassador:
      100:  637:		return 3;
        -:  638:	case cutpurse:
      110:  639:		return 4;
        -:  640:	case embargo:
       90:  641:		return 2;
        -:  642:	case outpost:
      120:  643:		return 5;
        -:  644:	case salvager:
      110:  645:		return 4;
        -:  646:	case sea_hag:
      110:  647:		return 4;
        -:  648:	case treasure_map:
      110:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       80:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       80:  658:	int i = 0;
       80:  659:	int j = 0;
       80:  660:	int k = 0;
       80:  661:	int x = 0;
       80:  662:	int index = 0;
       80:  663:	int currentPlayer = whoseTurn(state);
       80:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       80:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       80:  668:	int drawntreasure = 0;
       80:  669:	int cardDrawn = 0;
       80:  670:	int z = 0;// this is the counter for the temp hand
       80:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       80:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
    #####:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
    #####:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
    #####:  831:		state->numBuys++;//Increase buys by 1!
    #####:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
    #####:  869:			if (supplyCount(estate, state) > 0) {
    #####:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:				state->supplyCount[estate]--;//Decrement Estates
    #####:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
    #####:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
       30:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
       10:  891:			drawCard(currentPlayer, state);
       10:  892:			drawCard(currentPlayer, state);
        -:  893:		}
       20:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
       10:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
       10:  902:			discardCard(choice2, currentPlayer, state, 1);
       10:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
       30:  907:		discardCard(handPos, currentPlayer, state, 0);
       30:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
       50: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
       50: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
       30: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       30: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
       50: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
       50: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
       50: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
       50: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
       50: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
       50: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
       50: 1182:	return 0;
        -: 1183:}
        -: 1184:
       30: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
       30: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
       30: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
       30: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
       30: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
       30: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
       30: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
       30: 1219:	return 0;
        -: 1220:}
        -: 1221:
       80: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       80: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      480: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      400: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      250: 1234:			state->coins += 1;
        -: 1235:		}
      150: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
      100: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       80: 1247:	state->coins += bonus;
        -: 1248:
       80: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
    #####: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
    #####: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
    #####: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
    #####: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
    #####: 1288:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
    #####: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
    #####: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
    #####: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
    #####: 1302:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_cardtest2
File 'dominion.c'
Lines executed:42.12% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:6
        -:    0:Programs:6
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
     1800:   13:int compare(const void* a, const void* b) {
     1800:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
     1800:   16:	if (*(int*)a < *(int*)b)
      480:   17:		return -1;
     1320:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       60:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       60:   49:	SelectStream(1);
       60:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       60:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       60:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      660:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     6600:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     6000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       60:   78:	if (numPlayers == 2)
        -:   79:	{
       60:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       60:   92:	if (numPlayers == 2)
        -:   93:	{
       60:   94:		state->supplyCount[estate] = 8;
       60:   95:		state->supplyCount[duchy] = 8;
       60:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       60:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       60:  107:	state->supplyCount[silver] = 40;
       60:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
     1260:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
     9900:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
     9300:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      720:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
      120:  120:					if (numPlayers == 2) {
      120:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      480:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      600:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
     8700:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
      180:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
      120:  145:		state->deckCount[i] = 0;
      480:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      360:  148:			state->deck[i][j] = estate;
      360:  149:			state->deckCount[i]++;
        -:  150:		}
      960:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      840:  153:			state->deck[i][j] = copper;
      840:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
      180:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
      120:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
      180:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
      120:  171:		state->handCount[i] = 0;
      120:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
     1680:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
     1620:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       60:  187:	state->outpostPlayed = 0;
       60:  188:	state->phase = 0;
       60:  189:	state->numActions = 1;
       60:  190:	state->numBuys = 1;
       60:  191:	state->playedCardCount = 0;
       60:  192:	state->whoseTurn = 0;
       60:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      360:  197:	for (it = 0; it < 5; it++) {
      300:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       60:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       60:  203:	return 0;
        -:  204:}
        -:  205:
      141:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
      141:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
      141:  214:	if (state->deckCount[player] < 1)
       21:  215:		return -1;
      120:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
     1440:  219:	while (state->deckCount[player] > 0) {
     1200:  220:		card = floor(Random() * state->deckCount[player]);
     1200:  221:		newDeck[newDeckPos] = state->deck[player][card];
     1200:  222:		newDeckPos++;
     4560:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     3360:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
     1200:  226:		state->deckCount[player]--;
        -:  227:	}
     1320:  228:	for (i = 0; i < newDeckPos; i++) {
     1200:  229:		state->deck[player][i] = newDeck[i];
     1200:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
      120:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
     5670:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
     5670:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
     5670:  285:	who = state->whoseTurn;
        -:  286:
     5670:  287:	if (state->numBuys < 1) {
     1620:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
     1620:  290:		return -1;
        -:  291:	}
     4050:  292:	else if (supplyCount(supplyPos, state) < 1) {
     2510:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
     2510:  295:		return -1;
        -:  296:	}
     1540:  297:	else if (state->coins < getCost(supplyPos)) {
     1510:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
     1510:  300:		return -1;
        -:  301:	}
        -:  302:	else {
       30:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
       30:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
       30:  307:		state->coins = (state->coins) - (getCost(supplyPos));
       30:  308:		state->numBuys--;
       30:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
       30:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
     4150:  328:int supplyCount(int card, struct gameState *state) {
     4150:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      620:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      620:  334:	int count = 0;
        -:  335:
     3720:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     3100:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3720:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     3100:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23390:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22770:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      620:  351:	return count;
        -:  352:}
        -:  353:
      240:  354:int whoseTurn(struct gameState *state) {
      240:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      405:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      405:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
       21:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
       21:  547:		state->deckCount[player] = state->discardCount[player];
       21:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
       21:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
       21:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
       21:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
       21:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
       21:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
       21:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
       21:  568:		if (deckCounter == 0)
       21:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      384:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      384:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      384:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      384:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      384:  585:		state->deckCount[player]--;
      384:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      384:  589:	return 0;
        -:  590:}
        -:  591:
     4540:  592:int getCost(int cardNumber)
        -:  593:{
     4540:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
      150:  597:		return 0;
        -:  598:	case estate:
      190:  599:		return 2;
        -:  600:	case duchy:
      220:  601:		return 5;
        -:  602:	case province:
      280:  603:		return 8;
        -:  604:	case copper:
      150:  605:		return 0;
        -:  606:	case silver:
      180:  607:		return 3;
        -:  608:	case gold:
      240:  609:		return 6;
        -:  610:	case adventurer:
      240:  611:		return 6;
        -:  612:	case council_room:
      220:  613:		return 5;
        -:  614:	case feast:
      200:  615:		return 4;
        -:  616:	case gardens:
      200:  617:		return 4;
        -:  618:	case mine:
      220:  619:		return 5;
        -:  620:	case remodel:
      200:  621:		return 4;
        -:  622:	case smithy:
      200:  623:		return 4;
        -:  624:	case village:
      180:  625:		return 3;
        -:  626:	case baron:
      200:  627:		return 4;
        -:  628:	case great_hall:
      180:  629:		return 3;
        -:  630:	case minion:
      120:  631:		return 5;
        -:  632:	case steward:
      100:  633:		return 3;
        -:  634:	case tribute:
      120:  635:		return 5;
        -:  636:	case ambassador:
      100:  637:		return 3;
        -:  638:	case cutpurse:
      110:  639:		return 4;
        -:  640:	case embargo:
       90:  641:		return 2;
        -:  642:	case outpost:
      120:  643:		return 5;
        -:  644:	case salvager:
      110:  645:		return 4;
        -:  646:	case sea_hag:
      110:  647:		return 4;
        -:  648:	case treasure_map:
      110:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
       90:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
       90:  658:	int i = 0;
       90:  659:	int j = 0;
       90:  660:	int k = 0;
       90:  661:	int x = 0;
       90:  662:	int index = 0;
       90:  663:	int currentPlayer = whoseTurn(state);
       90:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
       90:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
       90:  668:	int drawntreasure = 0;
       90:  669:	int cardDrawn = 0;
       90:  670:	int z = 0;// this is the counter for the temp hand
       90:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
       90:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
       10:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
       10:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
       10:  831:		state->numBuys++;//Increase buys by 1!
       10:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
       10:  869:			if (supplyCount(estate, state) > 0) {
       10:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
       10:  871:				state->supplyCount[estate]--;//Decrement Estates
       10:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
       10:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
    #####:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
    #####:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
       30:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
       10:  891:			drawCard(currentPlayer, state);
       10:  892:			drawCard(currentPlayer, state);
        -:  893:		}
       20:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
       10:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
       10:  902:			discardCard(choice2, currentPlayer, state, 1);
       10:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
       30:  907:		discardCard(handPos, currentPlayer, state, 0);
       30:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
       70: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
       70: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
       50: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       50: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
       70: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
       70: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
       70: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
       70: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
       70: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
       70: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
       70: 1182:	return 0;
        -: 1183:}
        -: 1184:
       40: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
       40: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
       40: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
       40: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
       40: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
       40: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
       40: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
       40: 1219:	return 0;
        -: 1220:}
        -: 1221:
       90: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
       90: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      540: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      450: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      290: 1234:			state->coins += 1;
        -: 1235:		}
      160: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
      110: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
       90: 1247:	state->coins += bonus;
        -: 1248:
       90: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
       10: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
       40: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
       30: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
       10: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
       10: 1288:	discardCard(handPos, currentPlayer, state, 0);
       10: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
       10: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
       10: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
       10: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
       10: 1302:	discardCard(handPos, currentPlayer, state, 0);
       10: 1303:	return 0;
        -: 1304:}
    #####: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
    #####: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
    #####: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
    #####: 1313:	discardCard(handPos, currentPlayer, state, 0);
    #####: 1314:	return 0;
        -: 1315:}
    #####: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
    #####: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
    #####: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
    #####: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
    #####: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
    #####: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_cardtest3
File 'dominion.c'
Lines executed:44.35% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:7
        -:    0:Programs:7
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
     2100:   13:int compare(const void* a, const void* b) {
     2100:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
     2100:   16:	if (*(int*)a < *(int*)b)
      560:   17:		return -1;
     1540:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       70:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       70:   49:	SelectStream(1);
       70:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       70:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       70:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      770:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     7700:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     7000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       70:   78:	if (numPlayers == 2)
        -:   79:	{
       70:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       70:   92:	if (numPlayers == 2)
        -:   93:	{
       70:   94:		state->supplyCount[estate] = 8;
       70:   95:		state->supplyCount[duchy] = 8;
       70:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       70:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       70:  107:	state->supplyCount[silver] = 40;
       70:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
     1470:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
    11550:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
    10850:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      840:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
      140:  120:					if (numPlayers == 2) {
      140:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      560:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      700:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
    10150:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
      210:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
      140:  145:		state->deckCount[i] = 0;
      560:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      420:  148:			state->deck[i][j] = estate;
      420:  149:			state->deckCount[i]++;
        -:  150:		}
     1120:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
      980:  153:			state->deck[i][j] = copper;
      980:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
      210:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
      140:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
      210:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
      140:  171:		state->handCount[i] = 0;
      140:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
     1960:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
     1890:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       70:  187:	state->outpostPlayed = 0;
       70:  188:	state->phase = 0;
       70:  189:	state->numActions = 1;
       70:  190:	state->numBuys = 1;
       70:  191:	state->playedCardCount = 0;
       70:  192:	state->whoseTurn = 0;
       70:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      420:  197:	for (it = 0; it < 5; it++) {
      350:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       70:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       70:  203:	return 0;
        -:  204:}
        -:  205:
      161:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
      161:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
      161:  214:	if (state->deckCount[player] < 1)
       21:  215:		return -1;
      140:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
     1680:  219:	while (state->deckCount[player] > 0) {
     1400:  220:		card = floor(Random() * state->deckCount[player]);
     1400:  221:		newDeck[newDeckPos] = state->deck[player][card];
     1400:  222:		newDeckPos++;
     5320:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     3920:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
     1400:  226:		state->deckCount[player]--;
        -:  227:	}
     1540:  228:	for (i = 0; i < newDeckPos; i++) {
     1400:  229:		state->deck[player][i] = newDeck[i];
     1400:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
      140:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
     5670:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
     5670:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
     5670:  285:	who = state->whoseTurn;
        -:  286:
     5670:  287:	if (state->numBuys < 1) {
     1620:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
     1620:  290:		return -1;
        -:  291:	}
     4050:  292:	else if (supplyCount(supplyPos, state) < 1) {
     2510:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
     2510:  295:		return -1;
        -:  296:	}
     1540:  297:	else if (state->coins < getCost(supplyPos)) {
     1510:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
     1510:  300:		return -1;
        -:  301:	}
        -:  302:	else {
       30:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
       30:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
       30:  307:		state->coins = (state->coins) - (getCost(supplyPos));
       30:  308:		state->numBuys--;
       30:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
       30:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
     4150:  328:int supplyCount(int card, struct gameState *state) {
     4150:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      620:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      620:  334:	int count = 0;
        -:  335:
     3720:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     3100:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3720:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     3100:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23390:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22770:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      620:  351:	return count;
        -:  352:}
        -:  353:
      250:  354:int whoseTurn(struct gameState *state) {
      250:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      465:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      465:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
       21:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
       21:  547:		state->deckCount[player] = state->discardCount[player];
       21:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
       21:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
       21:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
       21:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
       21:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
       21:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
       21:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
       21:  568:		if (deckCounter == 0)
       21:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      444:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      444:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      444:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      444:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      444:  585:		state->deckCount[player]--;
      444:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      444:  589:	return 0;
        -:  590:}
        -:  591:
     4540:  592:int getCost(int cardNumber)
        -:  593:{
     4540:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
      150:  597:		return 0;
        -:  598:	case estate:
      190:  599:		return 2;
        -:  600:	case duchy:
      220:  601:		return 5;
        -:  602:	case province:
      280:  603:		return 8;
        -:  604:	case copper:
      150:  605:		return 0;
        -:  606:	case silver:
      180:  607:		return 3;
        -:  608:	case gold:
      240:  609:		return 6;
        -:  610:	case adventurer:
      240:  611:		return 6;
        -:  612:	case council_room:
      220:  613:		return 5;
        -:  614:	case feast:
      200:  615:		return 4;
        -:  616:	case gardens:
      200:  617:		return 4;
        -:  618:	case mine:
      220:  619:		return 5;
        -:  620:	case remodel:
      200:  621:		return 4;
        -:  622:	case smithy:
      200:  623:		return 4;
        -:  624:	case village:
      180:  625:		return 3;
        -:  626:	case baron:
      200:  627:		return 4;
        -:  628:	case great_hall:
      180:  629:		return 3;
        -:  630:	case minion:
      120:  631:		return 5;
        -:  632:	case steward:
      100:  633:		return 3;
        -:  634:	case tribute:
      120:  635:		return 5;
        -:  636:	case ambassador:
      100:  637:		return 3;
        -:  638:	case cutpurse:
      110:  639:		return 4;
        -:  640:	case embargo:
       90:  641:		return 2;
        -:  642:	case outpost:
      120:  643:		return 5;
        -:  644:	case salvager:
      110:  645:		return 4;
        -:  646:	case sea_hag:
      110:  647:		return 4;
        -:  648:	case treasure_map:
      110:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
      100:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
      100:  658:	int i = 0;
      100:  659:	int j = 0;
      100:  660:	int k = 0;
      100:  661:	int x = 0;
      100:  662:	int index = 0;
      100:  663:	int currentPlayer = whoseTurn(state);
      100:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
      100:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
      100:  668:	int drawntreasure = 0;
      100:  669:	int cardDrawn = 0;
      100:  670:	int z = 0;// this is the counter for the temp hand
      100:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
      100:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
       10:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
       10:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
       10:  831:		state->numBuys++;//Increase buys by 1!
       10:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
       10:  869:			if (supplyCount(estate, state) > 0) {
       10:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
       10:  871:				state->supplyCount[estate]--;//Decrement Estates
       10:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
       10:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
       10:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
       10:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
       40:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
       10:  891:			drawCard(currentPlayer, state);
       10:  892:			drawCard(currentPlayer, state);
        -:  893:		}
       30:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
       10:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
       20:  902:			discardCard(choice2, currentPlayer, state, 1);
       20:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
       40:  907:		discardCard(handPos, currentPlayer, state, 0);
       40:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
      120: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
      120: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
       80: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       80: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
      120: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
      120: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
      120: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
      120: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
      120: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
      120: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
      120: 1182:	return 0;
        -: 1183:}
        -: 1184:
       40: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
       40: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
       40: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
       40: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
       40: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
       40: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
       40: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
       40: 1219:	return 0;
        -: 1220:}
        -: 1221:
      100: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
      100: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      600: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      500: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      330: 1234:			state->coins += 1;
        -: 1235:		}
      170: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
      120: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
      100: 1247:	state->coins += bonus;
        -: 1248:
      100: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
       10: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
       40: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
       30: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
       10: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
       10: 1288:	discardCard(handPos, currentPlayer, state, 0);
       10: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
       10: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
       10: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
       10: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
       10: 1302:	discardCard(handPos, currentPlayer, state, 0);
       10: 1303:	return 0;
        -: 1304:}
       10: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
       10: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
       10: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
       10: 1313:	discardCard(handPos, currentPlayer, state, 0);
       10: 1314:	return 0;
        -: 1315:}
       10: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
       10: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
       10: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
       10: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
       10: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
       10: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

=================================================
merrittm_cardtest4
File 'dominion.c'
Lines executed:44.35% of 584
dominion.c:creating 'dominion.c.gcov'

=================================================
        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:8
        -:    0:Programs:8
        -:    1:/*********************************************************************
        -:    2:** Filename		:	dominion.c
        -:    3:** File Location:	dominion/final_project/classmate_implementations/cs362w16_gonsalvg/
        -:    4:** Author		:	Griffin Gonsalves
        -:    5:*********************************************************************/
        -:    6:#include "./dominion.h"
        -:    7:#include "./dominion_helpers.h"
        -:    8:#include "./rngs.h"
        -:    9:#include <stdio.h>
        -:   10:#include <math.h>
        -:   11:#include <stdlib.h>
        -:   12://initial test
     2400:   13:int compare(const void* a, const void* b) {
     2400:   14:	if (*(int*)a > *(int*)b)
    #####:   15:		return 1;
     2400:   16:	if (*(int*)a < *(int*)b)
      640:   17:		return -1;
     1760:   18:	return 0;
        -:   19:}
        -:   20:
    #####:   21:struct gameState* newGame() {
    #####:   22:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   23:	return g;
        -:   24:}
        -:   25:
    #####:   26:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   27:	int k8, int k9, int k10) {
    #####:   28:	int* k = malloc(10 * sizeof(int));
    #####:   29:	k[0] = k1;
    #####:   30:	k[1] = k2;
    #####:   31:	k[2] = k3;
    #####:   32:	k[3] = k4;
    #####:   33:	k[4] = k5;
    #####:   34:	k[5] = k6;
    #####:   35:	k[6] = k7;
    #####:   36:	k[7] = k8;
    #####:   37:	k[8] = k9;
    #####:   38:	k[9] = k10;
    #####:   39:	return k;
        -:   40:}
        -:   41:
       80:   42:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   43:struct gameState *state) {
        -:   44:
        -:   45:	int i;
        -:   46:	int j;
        -:   47:	int it;
        -:   48:	//set up random number generator
       80:   49:	SelectStream(1);
       80:   50:	PutSeed((long)randomSeed);
        -:   51:
        -:   52:	//check number of players
       80:   53:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   54:	{
    #####:   55:		return -1;
        -:   56:	}
        -:   57:
        -:   58:	//set number of players
       80:   59:	state->numPlayers = numPlayers;
        -:   60:
        -:   61:	//check selected kingdom cards are different
      880:   62:	for (i = 0; i < 10; i++)
        -:   63:	{
     8800:   64:		for (j = 0; j < 10; j++)
        -:   65:		{
     8000:   66:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   67:			{
    #####:   68:				return -1;
        -:   69:			}
        -:   70:		}
        -:   71:	}
        -:   72:
        -:   73:
        -:   74:	//initialize supply
        -:   75:	///////////////////////////////
        -:   76:
        -:   77:	//set number of Curse cards
       80:   78:	if (numPlayers == 2)
        -:   79:	{
       80:   80:		state->supplyCount[curse] = 10;
        -:   81:	}
    #####:   82:	else if (numPlayers == 3)
        -:   83:	{
    #####:   84:		state->supplyCount[curse] = 20;
        -:   85:	}
        -:   86:	else
        -:   87:	{
    #####:   88:		state->supplyCount[curse] = 30;
        -:   89:	}
        -:   90:
        -:   91:	//set number of Victory cards
       80:   92:	if (numPlayers == 2)
        -:   93:	{
       80:   94:		state->supplyCount[estate] = 8;
       80:   95:		state->supplyCount[duchy] = 8;
       80:   96:		state->supplyCount[province] = 8;
        -:   97:	}
        -:   98:	else
        -:   99:	{
    #####:  100:		state->supplyCount[estate] = 12;
    #####:  101:		state->supplyCount[duchy] = 12;
    #####:  102:		state->supplyCount[province] = 12;
        -:  103:	}
        -:  104:
        -:  105:	//set number of Treasure cards
       80:  106:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       80:  107:	state->supplyCount[silver] = 40;
       80:  108:	state->supplyCount[gold] = 30;
        -:  109:
        -:  110:	//set number of Kingdom cards
     1680:  111:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  112:	{
    13200:  113:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  114:		{
    12400:  115:			if (kingdomCards[j] == i)
        -:  116:			{
        -:  117:				//check if card is a 'Victory' Kingdom card
      960:  118:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  119:				{
      160:  120:					if (numPlayers == 2) {
      160:  121:						state->supplyCount[i] = 8;
        -:  122:					}
    #####:  123:					else { state->supplyCount[i] = 12; }
        -:  124:				}
        -:  125:				else
        -:  126:				{
      640:  127:					state->supplyCount[i] = 10;
        -:  128:				}
      800:  129:				break;
        -:  130:			}
        -:  131:			else    //card is not in the set choosen for the game
        -:  132:			{
    11600:  133:				state->supplyCount[i] = -1;
        -:  134:			}
        -:  135:		}
        -:  136:
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	//supply intilization complete
        -:  141:
        -:  142:	//set player decks
      240:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
      160:  145:		state->deckCount[i] = 0;
      640:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
      480:  148:			state->deck[i][j] = estate;
      480:  149:			state->deckCount[i]++;
        -:  150:		}
     1280:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
     1120:  153:			state->deck[i][j] = copper;
     1120:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	//shuffle player decks
      240:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
      160:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//draw player hands
      240:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		//initialize hand size to zero
      160:  171:		state->handCount[i] = 0;
      160:  172:		state->discardCount[i] = 0;
        -:  173:		//draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	//set embargo tokens to 0 for all supply piles
     2240:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
     2160:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	//initialize first player's turn
       80:  187:	state->outpostPlayed = 0;
       80:  188:	state->phase = 0;
       80:  189:	state->numActions = 1;
       80:  190:	state->numBuys = 1;
       80:  191:	state->playedCardCount = 0;
       80:  192:	state->whoseTurn = 0;
       80:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	//int it; move to top
        -:  195:
        -:  196:	//Moved draw cards to here, only drawing at the start of a turn
      480:  197:	for (it = 0; it < 5; it++) {
      400:  198:		drawCard(state->whoseTurn, state);
        -:  199:	}
        -:  200:
       80:  201:	updateCoins(state->whoseTurn, state, 0);
        -:  202:
       80:  203:	return 0;
        -:  204:}
        -:  205:
      181:  206:int shuffle(int player, struct gameState *state) {
        -:  207:
        -:  208:
        -:  209:	int newDeck[MAX_DECK];
      181:  210:	int newDeckPos = 0;
        -:  211:	int card;
        -:  212:	int i;
        -:  213:
      181:  214:	if (state->deckCount[player] < 1)
       21:  215:		return -1;
      160:  216:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  217:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  218:
     1920:  219:	while (state->deckCount[player] > 0) {
     1600:  220:		card = floor(Random() * state->deckCount[player]);
     1600:  221:		newDeck[newDeckPos] = state->deck[player][card];
     1600:  222:		newDeckPos++;
     6080:  223:		for (i = card; i < state->deckCount[player] - 1; i++) {
     4480:  224:			state->deck[player][i] = state->deck[player][i + 1];
        -:  225:		}
     1600:  226:		state->deckCount[player]--;
        -:  227:	}
     1760:  228:	for (i = 0; i < newDeckPos; i++) {
     1600:  229:		state->deck[player][i] = newDeck[i];
     1600:  230:		state->deckCount[player]++;
        -:  231:	}
        -:  232:
      160:  233:	return 0;
        -:  234:}
        -:  235:
      650:  236:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  237:{
        -:  238:	int card;
      650:  239:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  240:
        -:  241:	//check if it is the right phase
      650:  242:	if (state->phase != 0)
        -:  243:	{
      450:  244:		return -1;
        -:  245:	}
        -:  246:
        -:  247:	//check if player has enough actions
      200:  248:	if (state->numActions < 1)
        -:  249:	{
       50:  250:		return -1;
        -:  251:	}
        -:  252:
        -:  253:	//get card played
      150:  254:	card = handCard(handPos, state);
        -:  255:
        -:  256:	//check if selected card is an action
      150:  257:	if (card < adventurer || card > treasure_map)
        -:  258:	{
      100:  259:		return -1;
        -:  260:	}
        -:  261:
        -:  262:	//play card
       50:  263:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  264:	{
       50:  265:		return -1;
        -:  266:	}
        -:  267:
        -:  268:	//reduce number of actions
    #####:  269:	state->numActions--;
        -:  270:
        -:  271:	//update coins (Treasure cards may be added with card draws)
    #####:  272:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  273:
    #####:  274:	return 0;
        -:  275:}
        -:  276:
     5670:  277:int buyCard(int supplyPos, struct gameState *state) {
        -:  278:	int who;
     5670:  279:	if (DEBUG) {
        -:  280:		printf("Entering buyCard...\n");
        -:  281:	}
        -:  282:
        -:  283:	// I don't know what to do about the phase thing.
        -:  284:
     5670:  285:	who = state->whoseTurn;
        -:  286:
     5670:  287:	if (state->numBuys < 1) {
     1620:  288:		if (DEBUG)
        -:  289:			printf("You do not have any buys left\n");
     1620:  290:		return -1;
        -:  291:	}
     4050:  292:	else if (supplyCount(supplyPos, state) < 1) {
     2510:  293:		if (DEBUG)
        -:  294:			printf("There are not any of that type of card left\n");
     2510:  295:		return -1;
        -:  296:	}
     1540:  297:	else if (state->coins < getCost(supplyPos)) {
     1510:  298:		if (DEBUG)
        -:  299:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
     1510:  300:		return -1;
        -:  301:	}
        -:  302:	else {
       30:  303:		state->phase = 1;
        -:  304:		//state->supplyCount[supplyPos]--;
       30:  305:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  306:
       30:  307:		state->coins = (state->coins) - (getCost(supplyPos));
       30:  308:		state->numBuys--;
       30:  309:		if (DEBUG)
        -:  310:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  311:	}
        -:  312:
        -:  313:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  314:	//state->discardCount[who]++;
        -:  315:
       30:  316:	return 0;
        -:  317:}
        -:  318:
    #####:  319:int numHandCards(struct gameState *state) {
    #####:  320:	return state->handCount[whoseTurn(state)];
        -:  321:}
        -:  322:
      150:  323:int handCard(int handPos, struct gameState *state) {
      150:  324:	int currentPlayer = whoseTurn(state);
      150:  325:	return state->hand[currentPlayer][handPos];
        -:  326:}
        -:  327:
     4180:  328:int supplyCount(int card, struct gameState *state) {
     4180:  329:	return state->supplyCount[card];
        -:  330:}
        -:  331:
      620:  332:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  333:	int i;
      620:  334:	int count = 0;
        -:  335:
     3720:  336:	for (i = 0; i < state->deckCount[player]; i++)
        -:  337:	{
     3100:  338:		if (state->deck[player][i] == card) count++;
        -:  339:	}
        -:  340:
     3720:  341:	for (i = 0; i < state->handCount[player]; i++)
        -:  342:	{
     3100:  343:		if (state->hand[player][i] == card) count++;
        -:  344:	}
        -:  345:
    23390:  346:	for (i = 0; i < state->discardCount[player]; i++)
        -:  347:	{
    22770:  348:		if (state->discard[player][i] == card) count++;
        -:  349:	}
        -:  350:
      620:  351:	return count;
        -:  352:}
        -:  353:
      260:  354:int whoseTurn(struct gameState *state) {
      260:  355:	return state->whoseTurn;
        -:  356:}
        -:  357:
    #####:  358:int endTurn(struct gameState *state) {
        -:  359:	int k;
        -:  360:	int i;
    #####:  361:	int currentPlayer = whoseTurn(state);
        -:  362:
        -:  363:	//Discard hand
    #####:  364:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
    #####:  365:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  366:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  367:	}
    #####:  368:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  369:
        -:  370:	//Code for determining the player
    #####:  371:	if (currentPlayer < (state->numPlayers - 1)) {
    #####:  372:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  373:	}
        -:  374:	else {
    #####:  375:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  376:	}
        -:  377:
    #####:  378:	state->outpostPlayed = 0;
    #####:  379:	state->phase = 0;
    #####:  380:	state->numActions = 1;
    #####:  381:	state->coins = 0;
    #####:  382:	state->numBuys = 1;
    #####:  383:	state->playedCardCount = 0;
    #####:  384:	state->handCount[state->whoseTurn] = 0;
        -:  385:
        -:  386:	//int k; move to top
        -:  387:	//Next player draws hand
    #####:  388:	for (k = 0; k < 5; k++) {
    #####:  389:		drawCard(state->whoseTurn, state);//Draw a card
        -:  390:	}
        -:  391:
        -:  392:	//Update money
    #####:  393:	updateCoins(state->whoseTurn, state, 0);
        -:  394:
    #####:  395:	return 0;
        -:  396:}
        -:  397:
    #####:  398:int isGameOver(struct gameState *state) {
        -:  399:	int i;
        -:  400:	int j;
        -:  401:
        -:  402:	//if stack of Province cards is empty, the game ends
    #####:  403:	if (state->supplyCount[province] == 0)
        -:  404:	{
    #####:  405:		return 1;
        -:  406:	}
        -:  407:
        -:  408:	//if three supply pile are at 0, the game ends
    #####:  409:	j = 0;
    #####:  410:	for (i = 0; i < 25; i++)
        -:  411:	{
    #####:  412:		if (state->supplyCount[i] == 0)
        -:  413:		{
    #####:  414:			j++;
        -:  415:		}
        -:  416:	}
    #####:  417:	if (j >= 3)
        -:  418:	{
    #####:  419:		return 1;
        -:  420:	}
        -:  421:
    #####:  422:	return 0;
        -:  423:}
        -:  424:
    #####:  425:int scoreFor(int player, struct gameState *state) {
        -:  426:
        -:  427:	int i;
    #####:  428:	int score = 0;
        -:  429:	//score from hand
    #####:  430:	for (i = 0; i < state->handCount[player]; i++)
        -:  431:	{
    #####:  432:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  433:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  434:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  435:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  436:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  437:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  438:	}
        -:  439:
        -:  440:	//score from discard
    #####:  441:	for (i = 0; i < state->discardCount[player]; i++)
        -:  442:	{
    #####:  443:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  444:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  445:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  446:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  447:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  448:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  449:	}
        -:  450:
        -:  451:	//score from deck
    #####:  452:	for (i = 0; i < state->discardCount[player]; i++)
        -:  453:	{
    #####:  454:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  455:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  456:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  457:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  458:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  459:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  460:	}
        -:  461:
    #####:  462:	return score;
        -:  463:}
        -:  464:
    #####:  465:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  466:	int i;
        -:  467:	int j;
        -:  468:	int highScore;
        -:  469:	int currentPlayer;
        -:  470:
        -:  471:	//get score for each player
    #####:  472:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  473:	{
        -:  474:		//set unused player scores to -9999
    #####:  475:		if (i >= state->numPlayers)
        -:  476:		{
    #####:  477:			players[i] = -9999;
        -:  478:		}
        -:  479:		else
        -:  480:		{
    #####:  481:			players[i] = scoreFor(i, state);
        -:  482:		}
        -:  483:	}
        -:  484:
        -:  485:	//find highest score
    #####:  486:	j = 0;
    #####:  487:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  488:	{
    #####:  489:		if (players[i] > players[j])
        -:  490:		{
    #####:  491:			j = i;
        -:  492:		}
        -:  493:	}
    #####:  494:	highScore = players[j];
        -:  495:
        -:  496:	//add 1 to players who had less turns
    #####:  497:	currentPlayer = whoseTurn(state);
    #####:  498:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  499:	{
    #####:  500:		if (players[i] == highScore && i > currentPlayer)
        -:  501:		{
    #####:  502:			players[i]++;
        -:  503:		}
        -:  504:	}
        -:  505:
        -:  506:	//find new highest score
    #####:  507:	j = 0;
    #####:  508:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  509:	{
    #####:  510:		if (players[i] > players[j])
        -:  511:		{
    #####:  512:			j = i;
        -:  513:		}
        -:  514:	}
    #####:  515:	highScore = players[j];
        -:  516:
        -:  517:	//set winners in array to 1 and rest to 0
    #####:  518:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  519:	{
    #####:  520:		if (players[i] == highScore)
        -:  521:		{
    #####:  522:			players[i] = 1;
        -:  523:		}
        -:  524:		else
        -:  525:		{
    #####:  526:			players[i] = 0;
        -:  527:		}
        -:  528:	}
        -:  529:
    #####:  530:	return 0;
        -:  531:}
        -:  532:
      525:  533:int drawCard(int player, struct gameState *state)
        -:  534:{
        -:  535:	int count;
        -:  536:	int deckCounter;
      525:  537:	if (state->deckCount[player] <= 0) {//Deck is empty
        -:  538:
        -:  539:	  //Step 1 Shuffle the discard pile back into a deck
        -:  540:		int i;
        -:  541:		//Move discard to deck
       21:  542:		for (i = 0; i < state->discardCount[player]; i++) {
    #####:  543:			state->deck[player][i] = state->discard[player][i];
    #####:  544:			state->discard[player][i] = -1;
        -:  545:		}
        -:  546:
       21:  547:		state->deckCount[player] = state->discardCount[player];
       21:  548:		state->discardCount[player] = 0;//Reset discard
        -:  549:
        -:  550:		//Shufffle the deck
       21:  551:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  552:
       21:  553:		if (DEBUG) {//Debug statements
        -:  554:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  555:		}
        -:  556:
       21:  557:		state->discardCount[player] = 0;
        -:  558:
        -:  559:		//Step 2 Draw Card
       21:  560:		count = state->handCount[player];//Get current player's hand count
        -:  561:
       21:  562:		if (DEBUG) {//Debug statements
        -:  563:			printf("Current hand count: %d\n", count);
        -:  564:		}
        -:  565:
       21:  566:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  567:
       21:  568:		if (deckCounter == 0)
       21:  569:			return -1;
        -:  570:
    #####:  571:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  572:		state->deckCount[player]--;
    #####:  573:		state->handCount[player]++;//Increment hand count
        -:  574:	}
        -:  575:
        -:  576:	else {
      504:  577:		int count = state->handCount[player];//Get current hand count for player
        -:  578:		int deckCounter;
      504:  579:		if (DEBUG) {//Debug statements
        -:  580:			printf("Current hand count: %d\n", count);
        -:  581:		}
        -:  582:
      504:  583:		deckCounter = state->deckCount[player];//Create holder for the deck count
      504:  584:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      504:  585:		state->deckCount[player]--;
      504:  586:		state->handCount[player]++;//Increment hand count
        -:  587:	}
        -:  588:
      504:  589:	return 0;
        -:  590:}
        -:  591:
     4540:  592:int getCost(int cardNumber)
        -:  593:{
     4540:  594:	switch (cardNumber)
        -:  595:	{
        -:  596:	case curse:
      150:  597:		return 0;
        -:  598:	case estate:
      190:  599:		return 2;
        -:  600:	case duchy:
      220:  601:		return 5;
        -:  602:	case province:
      280:  603:		return 8;
        -:  604:	case copper:
      150:  605:		return 0;
        -:  606:	case silver:
      180:  607:		return 3;
        -:  608:	case gold:
      240:  609:		return 6;
        -:  610:	case adventurer:
      240:  611:		return 6;
        -:  612:	case council_room:
      220:  613:		return 5;
        -:  614:	case feast:
      200:  615:		return 4;
        -:  616:	case gardens:
      200:  617:		return 4;
        -:  618:	case mine:
      220:  619:		return 5;
        -:  620:	case remodel:
      200:  621:		return 4;
        -:  622:	case smithy:
      200:  623:		return 4;
        -:  624:	case village:
      180:  625:		return 3;
        -:  626:	case baron:
      200:  627:		return 4;
        -:  628:	case great_hall:
      180:  629:		return 3;
        -:  630:	case minion:
      120:  631:		return 5;
        -:  632:	case steward:
      100:  633:		return 3;
        -:  634:	case tribute:
      120:  635:		return 5;
        -:  636:	case ambassador:
      100:  637:		return 3;
        -:  638:	case cutpurse:
      110:  639:		return 4;
        -:  640:	case embargo:
       90:  641:		return 2;
        -:  642:	case outpost:
      120:  643:		return 5;
        -:  644:	case salvager:
      110:  645:		return 4;
        -:  646:	case sea_hag:
      110:  647:		return 4;
        -:  648:	case treasure_map:
      110:  649:		return 4;
        -:  650:	}
        -:  651:
    #####:  652:	return -1;
        -:  653:}
        -:  654:
      110:  655:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState
        -:  656:	*state, int handPos, int *bonus)
        -:  657:{
      110:  658:	int i = 0;
      110:  659:	int j = 0;
      110:  660:	int k = 0;
      110:  661:	int x = 0;
      110:  662:	int index = 0;
      110:  663:	int currentPlayer = whoseTurn(state);
      110:  664:	int nextPlayer = currentPlayer + 1;
        -:  665:
      110:  666:	int tributeRevealedCards[2] = { -1, -1 };
        -:  667:	int temphand[MAX_HAND];// moved above the if statement
      110:  668:	int drawntreasure = 0;
      110:  669:	int cardDrawn = 0;
      110:  670:	int z = 0;// this is the counter for the temp hand
      110:  671:	if (nextPlayer > (state->numPlayers - 1)) {
    #####:  672:		nextPlayer = 0;
        -:  673:	}
        -:  674:
        -:  675:
        -:  676:	//uses switch to select card and perform actions
      110:  677:	switch (card)
        -:  678:	{
        -:  679:	case adventurer:
        -:  680:		//if this doesn't work call by ref for drawntreasure, cardDrawn, temphand
    #####:  681:		adventurer_cardEffect(state, drawntreasure, cardDrawn, temphand, currentPlayer, z);
        -:  682:
        -:  683:	case council_room:
        -:  684:		//+4 Cards
    #####:  685:		for (i = 0; i < 4; i++)
        -:  686:		{
    #####:  687:			drawCard(currentPlayer, state);
        -:  688:		}
        -:  689:
        -:  690:		//+1 Buy
    #####:  691:		state->numBuys++;
        -:  692:
        -:  693:		//Each other player draws a card
    #####:  694:		for (i = 0; i < state->numPlayers; i++)
        -:  695:		{
    #####:  696:			if (i != currentPlayer)
        -:  697:			{
    #####:  698:				drawCard(i, state);
        -:  699:			}
        -:  700:		}
        -:  701:
        -:  702:		//put played card in played card pile
    #####:  703:		discardCard(handPos, currentPlayer, state, 0);
        -:  704:
    #####:  705:		return 0;
        -:  706:
        -:  707:	case feast:
        -:  708:		//gain card with cost up to 5
        -:  709:		//Backup hand
    #####:  710:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  711:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  712:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  713:		}
        -:  714:		//Backup hand
        -:  715:
        -:  716:		//Update Coins for Buy
    #####:  717:		updateCoins(currentPlayer, state, 5);
    #####:  718:		x = 1;//Condition to loop on
    #####:  719:		while (x == 1) {//Buy one card
    #####:  720:			if (supplyCount(choice1, state) <= 0) {
    #####:  721:				if (DEBUG)
        -:  722:					printf("None of that card left, sorry!\n");
        -:  723:
    #####:  724:				if (DEBUG) {
        -:  725:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  726:				}
        -:  727:			}
    #####:  728:			else if (state->coins < getCost(choice1)) {
    #####:  729:				printf("That card is too expensive!\n");
        -:  730:
    #####:  731:				if (DEBUG) {
        -:  732:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  733:				}
        -:  734:			}
        -:  735:			else {
        -:  736:
    #####:  737:				if (DEBUG) {
        -:  738:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  739:				}
        -:  740:
    #####:  741:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
    #####:  742:				x = 0;//No more buying cards
        -:  743:
    #####:  744:				if (DEBUG) {
        -:  745:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  746:				}
        -:  747:
        -:  748:			}
        -:  749:		}
        -:  750:
        -:  751:		//Reset Hand
    #####:  752:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
    #####:  753:			state->hand[currentPlayer][i] = temphand[i];
    #####:  754:			temphand[i] = -1;
        -:  755:		}
        -:  756:		//Reset Hand
        -:  757:
    #####:  758:		return 0;
        -:  759:
        -:  760:	case gardens:
       50:  761:		gardens_cardEffect();
        -:  762:
        -:  763:	case mine:
       50:  764:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  765:
       50:  766:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  767:		{
       50:  768:			return -1;
        -:  769:		}
        -:  770:
    #####:  771:		if (choice2 > treasure_map || choice2 < curse)
        -:  772:		{
    #####:  773:			return -1;
        -:  774:		}
        -:  775:
    #####:  776:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  777:		{
    #####:  778:			return -1;
        -:  779:		}
        -:  780:
    #####:  781:		gainCard(choice2, state, 2, currentPlayer);
        -:  782:
        -:  783:		//discard card from hand
    #####:  784:		discardCard(handPos, currentPlayer, state, 0);
        -:  785:
        -:  786:		//discard trashed card
    #####:  787:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  788:		{
    #####:  789:			if (state->hand[currentPlayer][i] == j)
        -:  790:			{
    #####:  791:				discardCard(i, currentPlayer, state, 0);
    #####:  792:				break;
        -:  793:			}
        -:  794:		}
        -:  795:
    #####:  796:		return 0;
        -:  797:
        -:  798:	case remodel:
    #####:  799:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 0, currentPlayer);
        -:  807:
        -:  808:		//discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		//discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
        -:  821:
    #####:  822:		return 0;
        -:  823:
        -:  824:	case smithy:
       10:  825:		smithy_cardEffect(state, currentPlayer, i, handPos);
        -:  826:
        -:  827:	case village:
       20:  828:		village_cardEffect(state, currentPlayer, handPos);
        -:  829:
        -:  830:	case baron:
       20:  831:		state->numBuys++;//Increase buys by 1!
       20:  832:		if (choice1 > 0) {//Boolean true or going to discard an estate
    #####:  833:			int p = 0;//Iterator for hand!
    #####:  834:			int card_not_discarded = 1;//Flag for discard set!
    #####:  835:			while (card_not_discarded) {
    #####:  836:				if (state->hand[currentPlayer][p] == estate) {//Found an estate card!
    #####:  837:					state->coins += 4;//Add 4 coins to the amount of coins
    #####:  838:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  839:					state->discardCount[currentPlayer]++;
    #####:  840:					for (; p < state->handCount[currentPlayer]; p++) {
    #####:  841:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  842:					}
    #####:  843:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  844:					state->handCount[currentPlayer]--;
    #####:  845:					card_not_discarded = 0;//Exit the loop
        -:  846:				}
    #####:  847:				else if (p > state->handCount[currentPlayer]) {
    #####:  848:					if (DEBUG) {
        -:  849:						printf("No estate cards in your hand, invalid choice\n");
        -:  850:						printf("Must gain an estate if there are any\n");
        -:  851:					}
    #####:  852:					if (supplyCount(estate, state) > 0) {
    #####:  853:						gainCard(estate, state, 0, currentPlayer);
    #####:  854:						state->supplyCount[estate]--;//Decrement estates
    #####:  855:						if (supplyCount(estate, state) == 0) {
    #####:  856:							isGameOver(state);
        -:  857:						}
        -:  858:					}
    #####:  859:					card_not_discarded = 0;//Exit the loop
        -:  860:				}
        -:  861:
        -:  862:				else {
    #####:  863:					p++;//Next card
        -:  864:				}
        -:  865:			}
        -:  866:		}
        -:  867:
        -:  868:		else {
       20:  869:			if (supplyCount(estate, state) > 0) {
       20:  870:				gainCard(estate, state, 0, currentPlayer);//Gain an estate
       20:  871:				state->supplyCount[estate]--;//Decrement Estates
       20:  872:				if (supplyCount(estate, state) == 0) {
    #####:  873:					isGameOver(state);
        -:  874:				}
        -:  875:			}
        -:  876:		}
        -:  877:
        -:  878:
       20:  879:		return 0;
        -:  880:
        -:  881:	case great_hall:
       10:  882:		greatHall_cardEffect(state, currentPlayer, handPos);
        -:  883:
        -:  884:	case minion:
       10:  885:		minion_cardEffect(state, currentPlayer, handPos, i, j, choice1, choice2);
        -:  886:
        -:  887:	case steward:
       40:  888:		if (choice1 == 1)
        -:  889:		{
        -:  890:			//+2 cards
       10:  891:			drawCard(currentPlayer, state);
       10:  892:			drawCard(currentPlayer, state);
        -:  893:		}
       30:  894:		else if (choice1 == 2)
        -:  895:		{
        -:  896:			//+2 coins
       10:  897:			state->coins = state->coins + 2;
        -:  898:		}
        -:  899:		else
        -:  900:		{
        -:  901:			//trash 2 cards in hand
       20:  902:			discardCard(choice2, currentPlayer, state, 1);
       20:  903:			discardCard(choice3, currentPlayer, state, 1);
        -:  904:		}
        -:  905:
        -:  906:		//discard card from hand
       40:  907:		discardCard(handPos, currentPlayer, state, 0);
       40:  908:		return 0;
        -:  909:
        -:  910:	case tribute:
    #####:  911:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
    #####:  912:			if (state->deckCount[nextPlayer] > 0) {
    #####:  913:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  914:				state->deckCount[nextPlayer]--;
        -:  915:			}
    #####:  916:			else if (state->discardCount[nextPlayer] > 0) {
    #####:  917:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####:  918:				state->discardCount[nextPlayer]--;
        -:  919:			}
        -:  920:			else {
        -:  921:				//No Card to Reveal
    #####:  922:				if (DEBUG) {
        -:  923:					printf("No cards to reveal\n");
        -:  924:				}
        -:  925:			}
        -:  926:		}
        -:  927:
        -:  928:		else {
    #####:  929:			if (state->deckCount[nextPlayer] == 0) {
    #####:  930:				for (i = 0; i < state->discardCount[nextPlayer]; i++) {
    #####:  931:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  932:					state->deckCount[nextPlayer]++;
    #####:  933:					state->discard[nextPlayer][i] = -1;
    #####:  934:					state->discardCount[nextPlayer]--;
        -:  935:				}
        -:  936:
    #####:  937:				shuffle(nextPlayer, state);//Shuffle the deck
        -:  938:			}
    #####:  939:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  940:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  941:			state->deckCount[nextPlayer]--;
    #####:  942:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  943:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  944:			state->deckCount[nextPlayer]--;
        -:  945:		}
        -:  946:
    #####:  947:		if (tributeRevealedCards[0] == tributeRevealedCards[1]) {//If we have a duplicate card, just drop one
    #####:  948:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####:  949:			state->playedCardCount++;
    #####:  950:			tributeRevealedCards[1] = -1;
        -:  951:		}
        -:  952:
    #####:  953:		for (i = 0; i <= 2; i++) {
    #####:  954:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) {//Treasure cards
    #####:  955:				state->coins += 2;
        -:  956:			}
        -:  957:
    #####:  958:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) {//Victory Card Found
    #####:  959:				drawCard(currentPlayer, state);
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:			else {//Action Card
    #####:  963:				state->numActions = state->numActions + 2;
        -:  964:			}
        -:  965:		}
        -:  966:
    #####:  967:		return 0;
        -:  968:
        -:  969:	case ambassador:
    #####:  970:		j = 0;		//used to check if player has enough cards to discard
        -:  971:
    #####:  972:		if (choice2 > 2 || choice2 < 0)
        -:  973:		{
    #####:  974:			return -1;
        -:  975:		}
        -:  976:
    #####:  977:		if (choice1 == handPos)
        -:  978:		{
    #####:  979:			return -1;
        -:  980:		}
        -:  981:
    #####:  982:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  983:		{
    #####:  984:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -:  985:			{
    #####:  986:				j++;
        -:  987:			}
        -:  988:		}
    #####:  989:		if (j < choice2)
        -:  990:		{
    #####:  991:			return -1;
        -:  992:		}
        -:  993:
    #####:  994:		if (DEBUG)
        -:  995:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  996:
        -:  997:		//increase supply count for choosen card by amount being discarded
    #####:  998:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  999:
        -: 1000:		//each other player gains a copy of revealed card
    #####: 1001:		for (i = 0; i < state->numPlayers; i++)
        -: 1002:		{
    #####: 1003:			if (i != currentPlayer)
        -: 1004:			{
    #####: 1005:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1006:			}
        -: 1007:		}
        -: 1008:
        -: 1009:		//discard played card from hand
    #####: 1010:		discardCard(handPos, currentPlayer, state, 0);
        -: 1011:
        -: 1012:		//trash copies of cards returned to supply
    #####: 1013:		for (j = 0; j < choice2; j++)
        -: 1014:		{
    #####: 1015:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1016:			{
    #####: 1017:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1018:				{
    #####: 1019:					discardCard(i, currentPlayer, state, 1);
    #####: 1020:					break;
        -: 1021:				}
        -: 1022:			}
        -: 1023:		}
        -: 1024:
    #####: 1025:		return 0;
        -: 1026:
        -: 1027:	case cutpurse:
        -: 1028:
    #####: 1029:		updateCoins(currentPlayer, state, 2);
    #####: 1030:		for (i = 0; i < state->numPlayers; i++)
        -: 1031:		{
    #####: 1032:			if (i != currentPlayer)
        -: 1033:			{
    #####: 1034:				for (j = 0; j < state->handCount[i]; j++)
        -: 1035:				{
    #####: 1036:					if (state->hand[i][j] == copper)
        -: 1037:					{
    #####: 1038:						discardCard(j, i, state, 0);
    #####: 1039:						break;
        -: 1040:					}
    #####: 1041:					if (j == state->handCount[i])
        -: 1042:					{
    #####: 1043:						for (k = 0; k < state->handCount[i]; k++)
        -: 1044:						{
    #####: 1045:							if (DEBUG)
        -: 1046:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1047:						}
    #####: 1048:						break;
        -: 1049:					}
        -: 1050:				}
        -: 1051:
        -: 1052:			}
        -: 1053:
        -: 1054:		}
        -: 1055:
        -: 1056:		//discard played card from hand
    #####: 1057:		discardCard(handPos, currentPlayer, state, 0);
        -: 1058:
    #####: 1059:		return 0;
        -: 1060:
        -: 1061:
        -: 1062:	case embargo:
        -: 1063:		//+2 Coins
    #####: 1064:		state->coins = state->coins + 2;
        -: 1065:
        -: 1066:		//see if selected pile is in play
    #####: 1067:		if (state->supplyCount[choice1] == -1)
        -: 1068:		{
    #####: 1069:			return -1;
        -: 1070:		}
        -: 1071:
        -: 1072:		//add embargo token to selected supply pile
    #####: 1073:		state->embargoTokens[choice1]++;
        -: 1074:
        -: 1075:		//trash card
    #####: 1076:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1077:		return 0;
        -: 1078:
        -: 1079:	case outpost:
        -: 1080:		//set outpost flag
    #####: 1081:		state->outpostPlayed++;
        -: 1082:
        -: 1083:		//discard card
    #####: 1084:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1085:		return 0;
        -: 1086:
        -: 1087:	case salvager:
        -: 1088:		//+1 buy
    #####: 1089:		state->numBuys++;
        -: 1090:
    #####: 1091:		if (choice1)
        -: 1092:		{
        -: 1093:			//gain coins equal to trashed card
    #####: 1094:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1095:			//trash card
    #####: 1096:			discardCard(choice1, currentPlayer, state, 1);
        -: 1097:		}
        -: 1098:
        -: 1099:		//discard card
    #####: 1100:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1101:		return 0;
        -: 1102:
        -: 1103:	case sea_hag:
    #####: 1104:		for (i = 0; i < state->numPlayers; i++) {
    #####: 1105:			if (i != currentPlayer) {
    #####: 1106:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1107:				state->discardCount[i]++;
    #####: 1108:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1109:			}
        -: 1110:		}
    #####: 1111:		return 0;
        -: 1112:
        -: 1113:	case treasure_map:
        -: 1114:		//search hand for another treasure_map
    #####: 1115:		index = -1;
    #####: 1116:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1117:		{
    #####: 1118:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1119:			{
    #####: 1120:				index = i;
    #####: 1121:				break;
        -: 1122:			}
        -: 1123:		}
    #####: 1124:		if (index > -1)
        -: 1125:		{
        -: 1126:			//trash both treasure cards
    #####: 1127:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1128:			discardCard(index, currentPlayer, state, 1);
        -: 1129:
        -: 1130:			//gain 4 Gold cards
    #####: 1131:			for (i = 0; i < 4; i++)
        -: 1132:			{
    #####: 1133:				gainCard(gold, state, 1, currentPlayer);
        -: 1134:			}
        -: 1135:
        -: 1136:			//return success
    #####: 1137:			return 1;
        -: 1138:		}
        -: 1139:
        -: 1140:		//no second treasure_map found in hand
    #####: 1141:		return -1;
        -: 1142:	}
        -: 1143:
    #####: 1144:	return -1;
        -: 1145:}
        -: 1146:
      130: 1147:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1148:{
        -: 1149:
        -: 1150:	//if card is not trashed, added to Played pile
      130: 1151:	if (trashFlag < 1)
        -: 1152:	{
        -: 1153:		//add card to played pile
       90: 1154:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       90: 1155:		state->playedCardCount++;
        -: 1156:	}
        -: 1157:
        -: 1158:	//set played card to -1
      130: 1159:	state->hand[currentPlayer][handPos] = -1;
        -: 1160:
        -: 1161:	//remove card from player's hand
      130: 1162:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1163:	{
        -: 1164:		//reduce number of cards in hand
    #####: 1165:		state->handCount[currentPlayer]--;
        -: 1166:	}
      130: 1167:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1168:	{
        -: 1169:		//reduce number of cards in hand
    #####: 1170:		state->handCount[currentPlayer]--;
        -: 1171:	}
        -: 1172:	else
        -: 1173:	{
        -: 1174:		//replace discarded card with last card in hand
      130: 1175:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1176:		//set last card to -1
      130: 1177:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1178:		//reduce number of cards in hand
      130: 1179:		state->handCount[currentPlayer]--;
        -: 1180:	}
        -: 1181:
      130: 1182:	return 0;
        -: 1183:}
        -: 1184:
       50: 1185:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1186:{
        -: 1187:	//Note: supplyPos is enum of choosen card
        -: 1188:
        -: 1189:	//check if supply pile is empty (0) or card is not used in game (-1)
       50: 1190:	if (supplyCount(supplyPos, state) < 1)
        -: 1191:	{
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//added card for [whoseTurn] current player:
        -: 1196:	// toFlag = 0 : add to discard
        -: 1197:	// toFlag = 1 : add to deck
        -: 1198:	// toFlag = 2 : add to hand
        -: 1199:
       50: 1200:	if (toFlag == 1)
        -: 1201:	{
    #####: 1202:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1203:		state->deckCount[player]++;
        -: 1204:	}
       50: 1205:	else if (toFlag == 2)
        -: 1206:	{
    #####: 1207:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1208:		state->handCount[player]++;
        -: 1209:	}
        -: 1210:	else
        -: 1211:	{
       50: 1212:		state->discard[player][state->discardCount[player]] = supplyPos;
       50: 1213:		state->discardCount[player]++;
        -: 1214:	}
        -: 1215:
        -: 1216:	//decrease number in supply pile
       50: 1217:	state->supplyCount[supplyPos]--;
        -: 1218:
       50: 1219:	return 0;
        -: 1220:}
        -: 1221:
      110: 1222:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1223:{
        -: 1224:	int i;
        -: 1225:
        -: 1226:	//reset coin count
      110: 1227:	state->coins = 0;
        -: 1228:
        -: 1229:	//add coins for each Treasure card in player's hand
      660: 1230:	for (i = 0; i < state->handCount[player]; i++)
        -: 1231:	{
      550: 1232:		if (state->hand[player][i] == copper)
        -: 1233:		{
      370: 1234:			state->coins += 1;
        -: 1235:		}
      180: 1236:		else if (state->hand[player][i] == silver)
        -: 1237:		{
       50: 1238:			state->coins += 2;
        -: 1239:		}
      130: 1240:		else if (state->hand[player][i] == gold)
        -: 1241:		{
       50: 1242:			state->coins += 3;
        -: 1243:		}
        -: 1244:	}
        -: 1245:
        -: 1246:	//add bonus
      110: 1247:	state->coins += bonus;
        -: 1248:
      110: 1249:	return 0;
        -: 1250:}
        -: 1251:
    #####: 1252:int adventurer_cardEffect(struct gameState *state, int drawntreasure, int cardDrawn, int *temphand, int currentPlayer, int z) {
        -: 1253:
    #####: 1254:	while (drawntreasure < 2)
        -: 1255:	{
    #####: 1256:		if (state->deckCount[currentPlayer] < 1) {//if the deck is empty we need to shuffle discard and add to deck
    #####: 1257:			shuffle(currentPlayer, state);
        -: 1258:		}
        -: 1259:
    #####: 1260:		drawCard(currentPlayer, state);
    #####: 1261:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        -: 1262:
    #####: 1263:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold) drawntreasure++;
        -: 1264:
        -: 1265:		else
        -: 1266:		{
    #####: 1267:			temphand[z] = cardDrawn;
    #####: 1268:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####: 1269:			z++;
        -: 1270:		}
        -: 1271:	}
        -: 1272:
    #####: 1273:	while (z - 1 >= 0) {
    #####: 1274:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####: 1275:		z = z - 1;
        -: 1276:	}
        -: 1277:
    #####: 1278:	return 0;
        -: 1279:}
       10: 1280:int smithy_cardEffect(struct gameState *state, int currentPlayer, int i, int handPos) {
        -: 1281:	//+3 Cards
       40: 1282:	for (i = 0; i < 3; i++)
        -: 1283:	{
       30: 1284:		drawCard(currentPlayer, state);
        -: 1285:	}
       10: 1286:	state->numActions++;
        -: 1287:	//discard card from hand
       10: 1288:	discardCard(handPos, currentPlayer, state, 0);
       10: 1289:	return 0;
        -: 1290:}
       50: 1291:int gardens_cardEffect() {
       50: 1292:	return -1;
        -: 1293:}
       20: 1294:int village_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1295:	//+1 Card
       20: 1296:	drawCard(currentPlayer, state);
        -: 1297:
        -: 1298:	//+2 Actions
       20: 1299:	state->numActions = state->numActions + 2;
        -: 1300:
        -: 1301:	//discard played card from hand
       20: 1302:	discardCard(handPos, currentPlayer, state, 0);
       20: 1303:	return 0;
        -: 1304:}
       10: 1305:int greatHall_cardEffect(struct gameState *state, int currentPlayer, int handPos) {
        -: 1306:	//+1 Card
       10: 1307:	drawCard(currentPlayer, state);
        -: 1308:
        -: 1309:	//+1 Actions
       10: 1310:	state->numActions++;
        -: 1311:
        -: 1312:	//discard card from hand
       10: 1313:	discardCard(handPos, currentPlayer, state, 0);
       10: 1314:	return 0;
        -: 1315:}
       10: 1316:int minion_cardEffect(struct gameState *state, int currentPlayer, int handPos, int i, int j, int choice1, int choice2) {
        -: 1317:	//+1 action
       10: 1318:	state->numActions++;
        -: 1319:
        -: 1320:	//discard card from hand
       10: 1321:	discardCard(handPos, currentPlayer, state, 0);
        -: 1322:
       10: 1323:	if (choice1)		//+2 coins
        -: 1324:	{
       10: 1325:		state->coins = state->coins + 2;
        -: 1326:	}
        -: 1327:
    #####: 1328:	else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -: 1329:	{
        -: 1330:		//discard hand
    #####: 1331:		while (numHandCards(state) > 0)
        -: 1332:		{
    #####: 1333:			discardCard(handPos, currentPlayer, state, 0);
        -: 1334:		}
        -: 1335:
        -: 1336:		//draw 4
    #####: 1337:		for (i = 0; i < 4; i++)
        -: 1338:		{
    #####: 1339:			drawCard(currentPlayer, state);
        -: 1340:		}
        -: 1341:
        -: 1342:		//other players discard hand and redraw if hand size > 4
    #####: 1343:		for (i = 0; i < state->numPlayers; i++)
        -: 1344:		{
    #####: 1345:			if (i != currentPlayer)
        -: 1346:			{
    #####: 1347:				if (state->handCount[i] > 4)
        -: 1348:				{
        -: 1349:					//discard hand
    #####: 1350:					while (state->handCount[i] > 0)
        -: 1351:					{
    #####: 1352:						discardCard(handPos, i, state, 0);
        -: 1353:					}
        -: 1354:
        -: 1355:					//draw 4
    #####: 1356:					for (j = 0; j < 4; j++)
        -: 1357:					{
    #####: 1358:						drawCard(i, state);
    #####: 1359:						state->numActions++;
        -: 1360:					}
        -: 1361:				}
        -: 1362:			}
        -: 1363:		}
        -: 1364:	}
       10: 1365:	return 0;
        -: 1366:}
        -: 1367:
        -: 1368://end of dominion.c

